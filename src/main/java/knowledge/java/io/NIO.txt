https://zhuanlan.zhihu.com/p/23488863
------------------------------------------------------
NIO如何工作
------------------------------------------------------

所有的系统I/O都分为两个阶段：等待就绪和操作。

举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。

需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；
而真正的读写操作的阻塞是使用CPU的，真正在"干活"，而且这个过程非常快，属于memory copy，
带宽通常在1GB/s级别以上，可以理解为基本不耗时。

传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。
对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。

最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。

换句话说，
BIO里用户最关心“我要读”，
NIO里用户最关心"我可以读了"，
在AIO模型里用户更需要关注的是“读完了”。

NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，
真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。

------------------------------------------------------
如何利用事件模型单线程处理所有I/O请求？
------------------------------------------------------

NIO的主要事件有几个：
读就绪、
写就绪、
有新连接到来。

1.首先需要注册当这几个事件到来的时候所对应的处理器。然后在合适的时机告诉事件选择器：我对这个事件感兴趣。
2.其次，用一个死循环选择就绪的事件.注意，select是阻塞的，所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。

简单的Reactor模式：
注册所有感兴趣的事件处理器，单线程轮询选择就绪事件，执行事件处理器。

------------------------------------------------------
NIO是怎么解决掉线程的瓶颈并处理海量连接的？
------------------------------------------------------
NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。
除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。

并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。

单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。
但现在的服务器，一般都是多核处理器，如果能够利用多核心进行I/O，无疑对效率会有更大的提高。

仔细分析一下我们需要的线程，其实主要包括以下几种：
1. 事件分发器，单线程选择就绪的事件。
2. I/O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。
3. 业务线程，在处理完I/O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I/O，如DB操作，RPC等。
   只要有阻塞，就需要单独的线程。

注意：Java的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。
     因此，如果有多个I/O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。

另外：连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。

------------------------------------------------------
Proactor与Reactor
------------------------------------------------------
一般情况下，I/O 复用机制需要事件分发器（event dispatcher）。
事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者

开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；
事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。

涉及到事件分发器的两种模式称为：Reactor和Proactor。 Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。

------------------------------------------------------
Selector.wakeup()
------------------------------------------------------
解除阻塞在Selector.select()/select(long)上的线程，立即返回。

------------------------------------------------------
Buffer的选择
------------------------------------------------------
通常情况下，操作系统的一次写操作分为两步：
1. 将数据从用户空间拷贝到系统空间。
2. 从系统空间往网卡写。同理，读操作也分为两步：
  2.1 将数据从网卡拷贝到系统空间；
  2.2 将数据从系统空间拷贝到用户空间。
对于NIO来说，缓存的使用可以使用DirectByteBuffer和HeapByteBuffer。
如果使用了DirectByteBuffer，一般来说可以减少一次系统空间到用户空间的拷贝。
但Buffer创建和销毁的成本更高，更不宜维护，通常会用内存池来提高性能。
如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer；反之可以用directBuffer。

------------------------------------------------------
NIO存在的问题
------------------------------------------------------
使用NIO != 高性能，当连接数<1000，并发程度不高或者局域网环境下NIO并没有显著的性能优势。
NIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。
推荐大家使用成熟的NIO框架，如Netty，MINA等。解决了很多NIO的陷阱，并屏蔽了操作系统的差异，有较好的性能和编程模型。

------------------------------------------------------
总结
------------------------------------------------------
1. 事件驱动模型
2. 避免多线程
3. 单线程处理多任务
4. 非阻塞I/O，I/O读写不再阻塞，而是返回0
5. 基于block的传输，通常比基于流的传输更高效
6. 更高级的IO函数，zero-copy
7. IO多路复用大大提高了Java网络应用的可伸缩性和实用性

阻塞与非阻塞指的的是当不能进行读写（网卡满时的写/网卡空的时候的读）的时候，I/O 操作立即返回还是阻塞；
同步异步指的是，当数据已经ready的时候，读写操作是同步读还是异步读，阶段不同而已。


------------------------------------------------------

https://www.zhihu.com/question/29005375/answer/667616386

如何学习Java的NIO？
------------------------------------------------------

IO操作往往在两个场景下会用到：
1. 文件IO
2. 网络IO

可简单认为：IO是面向流的处理，NIO是面向块(缓冲区)的处理
1. 面向流的I/O 系统一次一个字节地处理数据。
2. 一个面向块(缓冲区)的I/O系统以块的形式处理数据。

NIO主要有三个核心部分组成：
1. buffer缓冲区
2. Channel管道
3. Selector选择器

相对于传统IO而言，流是单向的。对于NIO而言，有了Channel管道这个概念，我们的读写都是双向的。
缓冲区就是数组，用以存储不同数据类型

缓冲区的核心方法
1. put() 写数据到缓冲区中
2. get() 读取缓冲区的数据
3. filp() 切换成读/写模式
4. clear() 会“清空”缓冲区 (数据没有真正被清空，只是被遗忘掉了)

4个核心变量属性来提供关于其所包含的数组的信息
1. 容量Capacity 缓冲区能够容纳的数据元素的最大数量。容量在缓冲区创建时被设定，并且永远不能被改变。(因为底层是数组)
2. 上界Limit 缓冲区里的数据的总数，代表了当前缓冲区中一共有多少数据。
3. 位置Position 下一个要被读或写的元素的位置。Position会自动由相应的 get( )和 put( )函数更新。
4. 标记Mark 一个备忘位置。用于记录上一次读写的位置。

Channel通道只负责传输数据、不直接操作数据的。操作数据都是通过Buffer缓冲区来进行操作！
FileChannel配合缓冲区实现文件复制的功能 (FileChannel配合缓冲区实现文件复制的功能)
通道之间通过transfer()实现数据的传输(直接操作缓冲区)：

------------------------------------------------------
直接与非直接缓冲区
------------------------------------------------------

1. 非直接缓冲区是需要经过一个：copy的阶段的(从内核空间copy到用户空间)
2. 直接缓冲区不需要经过copy阶段，也可以理解成--->内存映射文件，

使用直接缓冲区有两种方式：(驻留在堆外)
1. 缓冲区创建的时候分配的是直接缓冲区
2. 在FileChannel上调用map()方法，将文件直接映射到内存中创建

分散读取(scatter)：将一个通道中的数据分散读取到多个缓冲区中
聚集写入(gather)：将多个缓冲区中的数据集中写入到一个通道中

------------------------------------------------------
IO模型理解
------------------------------------------------------

根据UNIX网络编程对I/O模型的分类，在UNIX可以归纳成5种I/O模型：

1. 阻塞I/O
2. 非阻塞I/O
3. I/O多路复用
4. 信号驱动I/O
5. 异步I/O

文件描述符: Linux 的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令(api)，
           返回一个file descriptor（fd，文件描述符）。而对一个socket的读写也会有响应的描述符，
           称为socket fd（socket文件描述符），描述符就是一个数字，指向内核中的一个结构体（文件路径，数据区等一些属性）

用户空间和内核空间: 为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分

I/O运行过程: 当应用程序调用read方法时，是需要等待的--->从内核空间中找数据，再将内核空间的数据拷贝到用户空间的。

阻塞I/O模型: 在进程(用户)空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，
            在此期间一直等待。

非阻塞I/O模型: recvfrom从应用层到内核的时候，如果没有数据就直接返回一个EWOULDBLOCK错误，
              一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来。

I/O复用模型: 在Linux下它是这样子实现I/O复用模型的, 调用select/poll/epoll/pselect其中一个函数，
            传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。

（1）当用户进程调用了select，那么整个进程会被block；
（2）而同时，kernel会“监视”所有select负责的socket；
（3）当任何一个socket中的数据准备好了，select就会返回；
（4）这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程(空间)。
所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符其中的任意一个进入读就绪状态，
select()函数就可以返回。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。

------------------------------------------------------
我们通常使用NIO是在网络中使用的，网上大部分讨论NIO都是在网络通信的基础之上的！说NIO是非阻塞的NIO也是网络中体现的！

我们在网络中使用NIO往往是I/O模型的多路复用模型！
Selector选择器就可以比喻成麦当劳的广播。
一个线程能够管理多个Channel的状态

下面就简单总结一下使用NIO时的要点：
1. 将Socket通道注册到Selector中，监听感兴趣的事件
2. 当感兴趣的时间就绪时，则会进去我们处理的方法进行处理
3. 每处理完一次就绪事件，删除该选择键(因为我们已经处理完了)

------------------------------------------------------
管道和DatagramChannel