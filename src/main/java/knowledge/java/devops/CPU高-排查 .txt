问题：
1. 一个while死循环，会不会引起CPU使用率飙升
2. 频繁Young GC 会不会引起CPU使用率飙升
3. 线程数很高的应用，CPU使用率一定高吗？
4. CPU使用率高的应用，线程数一定高吗？
5. BLOCKED状态的线程会不会引起CPU使用率高？
6. 分时操作系统CPU是耗费us?还是耗费sy?

1. CPU使用率是如何计算的？
CPU% = 1 - idleTime/sysTime * 100
idleTime: CPU处于空闲状态的时间
sysTime: CPU处于用户态和内核态的时间总和

2. CPU使用率和什么有关系？
常见耗CPU的操作?
2.1 频繁GC,访问量高时，有可能造成频繁GC,甚至Full GC.当调用量大时，内存分配过快，就会造成GC线程不停执行，导致CPU飙高。
2.2 序列化和反序列化，例如程序执行XML解析时，调用量增大时导致CPU被打满。
2.3 加密，解密
2.4 正则表达式校验，JAVA正则表达式使用的引擎实现是NFA自动机，这种引擎在进行字符串匹配时会发生回溯。
2.5 线程上下文切换，当启动了很多线程，而这些线程都处于不断的阻塞状态（锁等待，IO等待等）和执行状态的变化过程中。
    当锁竞争激烈时，很容易出现这种情况。
2.6 某些线程在做无阻塞的运算，例如while(true)中不停的做运算，没有任何阻塞。写程序时，如果需要做很久的运算，可以适当sleep.

3. CPU与进程，线程有关系吗？
分时操作系统时通过轮询方式分配时间片进行进程调度的，如果进程在等待或阻塞，不会造成CPU资源使用。
线程称为轻进程，共享进程资源，CPU对线程也是分时调度。在JAVA中，线程的调度由JVM负责，一般分为分时调度和抢占式调度。

解答：
1. 一个while死循环，会不会引起CPU使用率飙升
会的，首先，死循环会调用CPU寄存器进行计数，这个操作会占用CPU
     其次，死循环不会让出CPU,除非操作系统时间片到期，但死循环会不断向系统申请时间片，直到系统没有空闲时间做别的事情。

2. 频繁Young GC 会不会引起CPU使用率飙升
会的，JVM进行垃圾回收，会计算内存和调用寄存器，一定会占用CPU
     例如，for循环从数据库查询数据集合，二次封装新的数据集合，如果量比较大时，内存没有足够空间，JVM会GC回收不再使用的数据。
     量大时会收到CPU使用率报警。

3. 线程数很高的应用，CPU使用率一定高吗？
不会，可通过Jstack查看系统线程状态，整个线程数很多，但Runnable和Running状态的线程不多，CPU不会高。
     例如，1000个线程中900个时Blocked和Waiting状态，这种线程不会占用CPU
     如果线程数很高，其实大多数原因时死锁，大量线程处于Blocked和Waiting状态。

4. CPU使用率高的应用，线程数一定高吗？
不会，CPU使用率高关键还是计算密集型操作，一个线程如果有大量计算，也会造成CPU使用率高。
     这也是为什么，一个大数据脚本任务，要大规模集群共同运算才能运行的原因。

5. BLOCKED状态的线程会不会引起CPU使用率高？
不一定，CPU高更多时因为上下文切换或者Runnable状态线程过多导致。Blocked状态，未必会引起CPU升高。

6. 分时操作系统CPU是耗费us?还是耗费sy?
us高还是sy高是什么意思？
通过top命令，查看us,sy
us用户空间占用CPU百分比，us高是因为程序导致的，通过分析线程堆栈，可以定位到问题线程。
sy内核空间占用CPU百分比，sy高的时候，如果时程序问题导致的，基本时因为线程上下文切换造成的。

经验：如何定位CPU使用率高？
1. 首先看线程数，JVM，系统load等参数，共同佐证。
2. 打印Jstack，通过工具分析线程情况，例如，fastThread，在线线程分析工具。

经验2：CPU高排查思路
1. 通过top找到CPU占用最高的pid
2. 通过top -Hp pid产看进程中占用CPU过高的tid （线程ID）
3. 通过printf '%x/n' tid把线程ID转化位十六进制
4. 通过Jstack pid|grep tid -A 30定位线程堆栈信息。

经验3： JVM old区占用高排查思路
1. top查看占用CPU高的进程
2. jstat -gcutil pid时间间隔，查看GC状态。
3. jmap - dump:format=b,file=name.dump pid 导出dump文件
4. 用VisualVM分析dump文件
